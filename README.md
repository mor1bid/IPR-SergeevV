## **Этап 1 - Begin**
    На данных коммитах я сделал версию с массивом из уже определённых целых чисел, среди которых, как и задано в работе, вычислялись элементы, которые длиной меньше, либо равны 3. Начал я с чисел для того, чтобы сначала "размяться" и правильно сделать как минимум алгоритм нахождения элементов<=3. Сделал я это через цикл for, в котором путём деления элементов массива счётчик, отражающий длину числа заполняется и через условие if else проверяется, меньше, либо равен элемент числу 3. Если элемент не равен, значит он не выводится. Элементы массива сменяются путём присваивания переменной i значение 0 и прибавление к нему 1 в конце цикла for. На втором коммите я решил добавить второй массив со строками в качестве "оболочки" для первого массива, чтобы при уже описанном расчёте выводились бы элементы второго массива, расположенные на соотвествующих с первым позициях 
    (ar[i] = 111 - ray[i] = ":-(").
## **Этап 2 - Alpha vers**
    На данных коммитах я переделал программу под большее соответствие с требованиями условия задачи. Теперь счётчик не требуется для определения длины элемента, так как от первого массива я избавился, и добавил вместо счётчика длину определённого элемента массива напрямую. Теперь в цикле for всего одна строка - собственно проверка длины массива через if else и вывод, подобный тому что изображён в данной задаче. Значения массива всё ещё предопределены, однако это не нарушает требования условия.
**Программа выполняет условие задачи.**

    Далее я решил оформить работу более функционально и свободно, встроив ввод строк с клавиатуры и формирование из них массивов через цикл while при bool = true. 
## **Этап 3 - Better version**
    Я сделал так, чтобы размер проверяемого массива рос с каждым вводом нового значения, придав переменной размера начального массива условно-бесконечное значение 999 и при достижении числа 4 пользователю выводится сообщение "Продолжить?", где при отрицательном ответе bool = false, а при положительном значение индекса i сбрасывается. Также я добавил вторую переменную размера для второго массива, равного введённому пользователем и который будет проходить проверку 
    if(элемент_массива<=3).
## **Этап 4 - Complete version + Experiment**
    На первых двух коммитах делал исправления оформления вывода решения задачи. На двух последних решил сегментировать код на 2 отдельных метода, а также сократить общее кол-во строк путём удаления лишнего второго массива ray и проверок, выводимых после ввода пользователем 4 значений, сделав вместо запроса "Продолжить? y/n:" для продолжения/отмены ввода новых элементов в первый массив возможность в любой момент вывести результат из имеющихся в массиве элементов, путём присваивание строке answ значение "", чтобы если пользователь нажал клавишу Enter -> bool = false, что означает конец цикла while, и переход от метода ProcessAr к методу BuildAr.
## Глоссарий
- Метод ``ProcessAr`` - здесь выполняется ввод пользователем строк и вывод их в следующий метод в целях выполнения условия задачи.
- Метод ``BuildAr`` - здесь выполняется проверка длины введённых пользователем элементов-строк в массиве ``ar``.
- ``i`` - переменная индекса.
- ``si`` - первая переменная размера массива, предопределена.
- ``ze`` - вторая переменная размера массива, изменяется в зависимости от кол-ва введённых значений.
- ``ar`` - одномерный массив.
- ``ent`` - переменная bool, сменяющаяся с изначального значения true по желанию пользователя.
- ``s`` - переменная string, вводимая с клавиатуры в массив ``ar``.
- ``answ`` - переменная string. При ``s``==``answ``, выводится результат из метода ``BuildAr``.
------
- ``ray`` - второй одномерный массив, заполняемый значениями из массива ``ar``. *Удалено.*
- ``ari`` - вторая переменная индекса для придания вводимым строкам ``s`` позиции в массиве ``ar``. *Удалено.*
